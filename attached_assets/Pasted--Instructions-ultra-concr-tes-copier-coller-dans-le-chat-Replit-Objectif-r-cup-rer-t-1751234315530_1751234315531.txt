### Instructions ultra-concrètes (à copier-coller dans le chat Replit)

**Objectif :** récupérer **tous** les contenus des 9 livres de Breslev listés ci-dessous sans rien oublier.

---

#### 1. Liste canonique des 9 ouvrages Breslev

| Titre affiché     | clé Sefaria (tref)  |
| ----------------- | ------------------- |
| Likoutei Moharan  | `Likutei_Moharan`   |
| Likoutei Halakhot | `Likutei_Halakhot`  |
| Likoutei Tefilot  | `Likutei_Tefilot`   |
| Likkutei Etzot    | `Likkutei_Etzot`    |
| Sefer HaMiddot    | `Sefer_HaMiddot`    |
| Sichot HaRan      | `Sichot_HaRan`      |
| Chayei Moharan    | `Chayei_Moharan`    |
| Shivchei HaRan    | `Shivchei_HaRan`    |
| Sippurei Maasiyot | `Sippurei_Maasiyot` |

*(c’est exactement la liste que l’utilisateur a donnée)*

---

#### 2. API Sefaria : ce qu’il faut savoir en **2 endpoints**

| Fonction                             | Endpoint                                                               | Exemple                              |
| ------------------------------------ | ---------------------------------------------------------------------- | ------------------------------------ |
| **Index / TOC** (structure du livre) | `GET /api/index/{Title}`                                               | `…/api/index/Likutei_Moharan`        |
| **Texte complet d’une référence**    | `GET /api/v3/texts/{Ref}?context=0&commentary=0&pad=0&wrapLinks=false` | `…/api/v3/texts/Likutei_Moharan.1.1` |

*Le v3 renvoie JSON déjà CORS-friendly (`Access-Control-Allow-Origin:*`).*

---

#### 3. Stratégie “crawler” simple (Front-end uniquement, zéro backend)

```ts
/**
 * 1. Récupère la table des matières du livre
 * 2. Génère toutes les refs feuille (chapitre§séif)
 * 3. Télécharge chaque ref en parallèle avec fetch()
 */
async function fetchEntireBook(title: string) {
  // 1. TOC
  const tocRes = await fetch(`https://www.sefaria.org/api/index/${title}`);
  const toc = await tocRes.json();

  // 2. Fonction récursive pour lister toutes les refs finales
  const leafRefs: string[] = [];
  const walk = (node: any) => {
    if (node.ref && (!node.nodes || node.nodes.length === 0) &&
        (!node.contents || node.contents.length === 0)) {
      leafRefs.push(node.ref.replace(/ /g, '_'));        // "Likutei Moharan 1:1"
    } else {
      (node.nodes ?? node.contents ?? []).forEach(walk); // deeper
    }
  };
  walk(toc.schema);   // toc.schema est la racine

  // 3. Téléchargement batch (limité à 5 fetch simultanés pour ne pas spammer)
  const CONCURRENCY = 5;
  const results: Record<string, any> = {};
  let i = 0;
  async function worker() {
    while (i < leafRefs.length) {
      const ref = leafRefs[i++];
      const url = `https://www.sefaria.org/api/v3/texts/${ref}?context=0&commentary=0&pad=0&wrapLinks=false`;
      const r = await fetch(url);            // v3
      if (r.ok) results[ref] = await r.json();
      await new Promise(res => setTimeout(res, 250)); // mini-pause (respect quota)
    }
  }
  await Promise.all(Array.from({ length: CONCURRENCY }, worker));
  console.log(`✔ ${title} : ${Object.keys(results).length} sections téléchargées`);
  return results;                              // objet JSON complet
}
```

**Comment on s’en sert ?**

```ts
const books = [
  'Likutei_Moharan',
  'Likutei_Halakhot',
  'Likutei_Tefilot',
  'Likkutei_Etzot',
  'Sefer_HaMiddot',
  'Sichot_HaRan',
  'Chayei_Moharan',
  'Shivchei_HaRan',
  'Sippurei_Maasiyot',
];

(async () => {
  for (const b of books) {
    await fetchEntireBook(b);
  }
})();
```

---

#### 4. Pourquoi **front-only** est acceptable ici ?

* Sefaria autorise CORS → pas besoin de proxy pour le texte.
* Peu d’utilisateurs simultanés → la limite v3 (\~10 req/s) suffit.
* SessionStorage ou IndexedDB peut stocker localement les JSON pour éviter de refetch.

---

#### 5. Si malgré tout CORS bloque (rare) : plan B “proxy léger”

```js
// server.js (Express minimal, port 5174)
import express from 'express'; import fetch from 'node-fetch';
const app = express();
app.get('/sefaria/*', async (req,res)=>{
  const target = 'https://www.sefaria.org' + req.originalUrl.replace('/sefaria','');
  const r = await fetch(target); res.set('Access-Control-Allow-Origin','*');
  r.ok ? res.status(200).send(await r.text())
      : res.status(r.status).send(await r.text());
});
app.listen(5174);
```

Puis côté front : `fetch('/sefaria/api/v3/texts/Likutei_Moharan.1.1?…')`.

---

### En résumé pour l’agent Replit :

1. **Implémente exactement le crawler ci-dessus** ou équivalent.
2. Stocke les résultats dans `sessionStorage` pour accélérer.
3. Pas de backend lourd ; si CORS OK, garde le front-only.
4. **Pas d’aperçu !** on veut le texte intégral (array de versets/paragraphe).
5. Chaque clic dans le sidebar passe le `tref` complet à Gemini (Mode 1).

Suivre ces 5 points garantit que **tous** les livres Breslev sont accessibles et analysables immédiatement.
