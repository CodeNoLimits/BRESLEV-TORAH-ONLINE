### Correctif cibl√© : remettre en route **TTS + Guidance + Analyser**

et √©viter la surcharge de Gemini en d√©coupant les enseignements ¬´ ◊ê / ◊ë / ◊í ‚Ä¶ ¬ª

---

## 1. Pourquoi le **TTS** est muet ?

| Cause probable                                                                                                  | Correctif concret                                                                                                                                                                                                                                                                              |
| --------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Voix absente** : le hook appelle `speechSynthesis.getVoices()` trop t√¥t (avant que les voix soient charg√©es). | Dans `useTTS`, ajouter un *lazy-loader* :  `js const loadVoices = () => new Promise(r => { let v = speechSynthesis.getVoices(); if (v.length) return r(v); speechSynthesis.onvoiceschanged = () => r(speechSynthesis.getVoices()); });`  Et n‚Äôappeler `speak()` qu‚Äôapr√®s `await loadVoices()`. |
| **Contexte navigateur bloqu√©** : le premier son doit √™tre d√©clench√© par une action utilisateur (Chrome/Edge).   | Au premier clic sur **Analyse** / **Guidance** / **Btn TTS**, appeler `window.speechSynthesis.resume()` puis lancer un court essai (`new SpeechSynthesisUtterance('')`) pour lever le blocage.                                                                                                 |
| **Langue mal mapp√©e** : `utterance.lang` ‚â† voix disponible (he-IL, fr-FR, en-US).                               | S√©lectionner la premi√®re voix qui **commence** par le code voulu :  `js const v = voices.find(v=>v.lang.startsWith(langCode));`                                                                                                                                                                |
| **Lecture interrompue** parce que `speak()` est appel√© chunk par chunk.                                         | Accumuler le texte complet puis appeler `speak(fullText)` **une fois** le stream termin√© (`reader.read()` ‚Üí done).                                                                                                                                                                             |
| **HTTPS requis** sur Chrome pour TTS.                                                                           | Tester en [https://repl.co](https://repl.co) ; sinon activer le flag *Always use HTTPS* ou servir en `https://<project>.<username>.repl.co`.                                                                                                                                                   |

### Patch minimal ‚Äì `useTTS.ts`

```ts
export const useTTS = (enabled: boolean, lang: 'fr'|'en'|'he') => {
  const loadVoices = () => new Promise<SpeechSynthesisVoice[]>(resolve=>{
      const v = speechSynthesis.getVoices();
      if (v.length) return resolve(v);
      speechSynthesis.onvoiceschanged = () => resolve(speechSynthesis.getVoices());
  });

  const speak = async (text: string) => {
    if (!enabled || !text) return;
    const voices = await loadVoices();
    const utter = new SpeechSynthesisUtterance(text);
    utter.lang = lang==='he' ? 'he-IL' : lang==='en' ? 'en-US' : 'fr-FR';
    utter.voice = voices.find(v=>v.lang.startsWith(utter.lang)) ?? null;
    utter.rate = .95;
    speechSynthesis.cancel();
    speechSynthesis.speak(utter);
  };
  return { speak };
};
```

Call `speak(fullResponse)` **apr√®s** que le streaming Gemini soit termin√©.

---

## 2. Pourquoi **Guidance** et **Analyser** n‚Äôenvoient rien ?

1. **Handlers absents**
   *V√©rifie :* dans `ChatView` les props sont bien pass√©es :

   ```tsx
   <GuidanceCounselor onFindAdvice={handleFindAdvice} ‚Ä¶/>
   <SnippetAnalyzer  onAnalyze={handleAnalyzeSnippet} ‚Ä¶/>
   ```

2. **streamAiResponse** ne re√ßoit pas le bon `mode`
   *Patch :*

   ```js
   onFindAdvice={txt=>streamAiResponse('advice',{text:txt})}
   onAnalyze={txt=>streamAiResponse('snippet',{text:txt})}
   ```

3. **Route proxy manquante**
   *test terminal :*

   ```bash
   curl -X POST https://<repl>.repl.co/gemini-api/chat -d '{"prompt":"ping"}' -H 'Content-Type: application/json'
   ```

   ‚Üí doit renvoyer du texte. Sinon revoir `proxy.js` (¬ß pr√©c√©dent).

4. **CORS** front‚Üíproxy
   Ajoute dans proxy :

   ```js
   app.use(require('cors')({ origin:'*' }));
   ```

---

## 3. D√©couper automatiquement les longs enseignements ¬´ ◊ê / ◊ë / ◊í ¬ª

### 3-a. Algorithme

1. Apr√®s avoir r√©cup√©r√© `text.he` (ou `text.en`) :

   ```js
   const raw = text.he.join('\n');         // tableau ‚Üí grande string
   const parts = raw.split(/(?:^|\n)([◊ê-◊™]\s?[.:])/g); // garde le d√©limiteur
   ```
2. Reconstituer en paires `[marker, paragraph]` et filtrer vide.
3. Dans `TextViewer` : afficher une table des sous-sections cliquables (liste de marqueurs).
4. Quand l‚Äôutilisateur clique *Analyse* avec **rien s√©lectionn√©** :
   *Frontend* envoie **par lot ‚â§ 1 000 caract√®res** :

   ```js
   for(const slice of chunk(parts.join('\n\n'), 1000)){ await streamAiResponse('study',{text:slice}); }
   ```

   Gemini re√ßoit chaque chunk ind√©pendamment ‚áí √©vite l‚Äôexplosion de tokens.

### 3-b. UX rapide

```tsx
{paragraphs.map((p,i)=>(
  <p key={i} onClick={()=>selectParagraph(i)}
     className={i===selected ? 'bg-sky-900/20' : ''}>
     <span className="font-bold text-amber-400">{p.marker}</span> {p.text}
  </p>
))}
```

---

## 4. Checklist ¬´ √áa doit marcher tout de suite ¬ª

| ‚úÖ | √Ä v√©rifier                                                                                                   | Fichier                                        |
| - | ------------------------------------------------------------------------------------------------------------ | ---------------------------------------------- |
| ‚òê | `POST /gemini-api/chat` renvoie du texte dans Postman                                                        | `proxy.js`                                     |
| ‚òê | `useTTS` charge les voix (>0) avant `speak()`                                                                | `useTTS.ts`                                    |
| ‚òê | `streamAiResponse` appelle `speak(fullText)` apr√®s le `done` du stream                                       | `App.tsx`                                      |
| ‚òê | Boutons appellent correctement leurs handlers avec `mode` ad√©quat                                            | `GuidanceCounselor.tsx`, `SnippetAnalyzer.tsx` |
| ‚òê | S√©lection vide ‚Üí d√©coupage en sous-paragraphes ‚â§ 1000 car.                                                   | `GeminiContextSvc.ts`                          |
| ‚òê | TTS greeting :  `useEffect(() => speak('S√©lectionnez la partie du texte que vous voulez que je lise‚Ä¶'), [])` | `App.tsx`                                      |

---

üí° **Astuce debug TTS** :

```js
console.table(speechSynthesis.getVoices().map(v=>({name:v.name, lang:v.lang})));
```

Si aucune voix fran√ßaise ou h√©bra√Øque ‚Üí Chrome/Edge lit quand m√™me via fallback US ; Safari iOS bloque sans HTTPS.

---

### En r√©sum√©

1. **Fixe le hook TTS** (lazy voice loader + speak apr√®s stream).
2. **V√©rifie la route `/gemini-api/chat`** ‚Äì si elle renvoie ¬´ pong ¬ª depuis curl, le front fonctionnera.
3. **Passe le mode correct** aux fonctions `streamAiResponse`.
4. **D√©coupe les enseignements** par marqueurs ◊ê/◊ë/◊í et envoie en petits blocs √† Gemini.

Applique ces correctifs ; les trois boutons fonctionneront et la lecture vocale saluera l‚Äôutilisateur puis lira exactement le passage choisi, dans la bonne langue.
