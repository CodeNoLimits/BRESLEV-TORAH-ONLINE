Absolument. En tant qu'architecte logiciel, j'ai analysÃ© en profondeur la structure de votre application "Le Compagnon du CÅ“ur". Le principal problÃ¨me qui empÃªche son fonctionnement est une sÃ©rie d'erreurs **CORS (Cross-Origin Resource Sharing)**, couplÃ©e Ã  une logique de rÃ©cupÃ©ration des textes qui doit Ãªtre optimisÃ©e et une gestion non sÃ©curisÃ©e de votre clÃ© d'API.

Voici une feuille de route prÃ©cise et impÃ©rative, fichier par fichier, Ã  transmettre Ã  votre dÃ©veloppeur pour une correction complÃ¨te et dÃ©finitive de l'application.

-----

### **Instructions ImpÃ©ratives pour la RÃ©paration de l'Application**

**Ã€ l'attention du dÃ©veloppeur,**

Les instructions suivantes doivent Ãªtre appliquÃ©es Ã  la lettre pour garantir le bon fonctionnement de l'application. Les problÃ¨mes principaux identifiÃ©s sont :

1.  **Violation des rÃ¨gles CORS** : Le client (navigateur) tente d'appeler l'API de Sefaria directement, ce qui est bloquÃ©.
2.  **Logique de rÃ©cupÃ©ration des donnÃ©es inefficace** : La bibliothÃ¨que Breslev n'est pas chargÃ©e correctement.
3.  **ClÃ© d'API exposÃ©e** : La clÃ© Gemini est visible cÃ´tÃ© client, ce qui reprÃ©sente un risque de sÃ©curitÃ© majeur.

La solution repose sur la mise en place d'un proxy serveur qui centralisera et sÃ©curisera tous les appels externes.

-----

### **Ã‰tape 1 : Mise en Place du Serveur Proxy (Correction CORS et SÃ©curitÃ©)**

1.  **Installer les dÃ©pendances du serveur :**
    Dans le terminal (Shell) de Replit, exÃ©cutez la commande suivante pour installer Express (un framework web pour Node.js), un middleware de proxy, et `cors` pour la gestion des permissions :

    ```bash
    npm install express http-proxy-middleware cors @google/generative-ai
    ```

2.  **CrÃ©er et configurer le serveur proxy :**
    CrÃ©ez un fichier nommÃ© `server.js` Ã  la racine de votre projet et insÃ©rez-y le code suivant. Ce serveur relaiera les appels Ã  Sefaria et Ã  Gemini.

    ```javascript
    // Fichier : server.js
    import express from 'express';
    import fetch from 'node-fetch';
    import cors from 'cors';
    import { GoogleGenerativeAI } from '@google/generative-ai';

    const app = express();
    app.use(cors());
    app.use(express.json());

    /* ============ Proxy pour Sefaria ============ */
    app.get('/sefaria/*', async (req, res) => {
      const targetUrl = 'https://www.sefaria.org' + req.originalUrl.replace('/sefaria', '');
      console.log(`[Sefaria Proxy] Forwarding to: ${targetUrl}`);
      try {
        const response = await fetch(targetUrl);
        res.status(response.status);
        response.body.pipe(res);
      } catch (error) {
        console.error('[Sefaria Proxy] Error:', error);
        res.status(500).json({ error: 'Proxy error for Sefaria' });
      }
    });

    /* ============ Proxy pour Gemini AI (sÃ©curisÃ©) ============ */
    if (!process.env.GEMINI_API_KEY) {
      throw new Error('ERREUR: La clÃ© API Gemini (GEMINI_API_KEY) est manquante dans les "Secrets".');
    }

    const ai = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
    const model = ai.getGenerativeModel({
      model: 'gemini-1.5-flash-latest',
      systemInstruction: {
        role: 'system',
        parts: [{
          text: `Tu es Le Compagnon du CÅ“ur, un guide spirituel expert des enseignements de Rabbi Nahman de Breslev. Tes rÃ©ponses doivent Ãªtre profondes, bienveillantes et uniquement en franÃ§ais. Lorsque tu analyses un texte, traduis-le d'abord intÃ©gralement en franÃ§ais, puis fournis ton analyse. Ignore toute question non spirituelle.`
        }]
      }
    });

    app.post('/gemini/chat', async (req, res) => {
      try {
        const { prompt } = req.body;
        console.log('[Gemini Proxy] Processing request...');
        const chat = model.startChat();
        const result = await chat.sendMessageStream(prompt);

        res.setHeader('Content-Type', 'text/plain; charset=utf-8');
        res.setHeader('Transfer-Encoding', 'chunked');
        res.flushHeaders();

        for await (const chunk of result.stream) {
          res.write(chunk.text());
        }
        res.end();
      } catch (e) {
        console.error('[Gemini Proxy Error]', e);
        res.status(500).json({ error: 'Failed to communicate with Gemini API' });
      }
    });

    const PORT = process.env.PORT || 3001;
    app.listen(PORT, () => console.log(`ğŸš€ Proxy server running on port ${PORT}`));
    ```

3.  **SÃ©curiser la clÃ© d'API Gemini :**

      - Dans Replit, allez dans l'onglet **"Secrets"** (icÃ´ne en forme de cadenas).
      - CrÃ©ez un nouveau secret :
          - **ClÃ© (key) :** `GEMINI_API_KEY`
          - **Valeur (value) :** Collez votre clÃ© API Gemini ici (celle commenÃ§ant par `AIzaSy...`).
      - **Supprimez la clÃ© de tous les fichiers du client \!** Elle ne doit plus jamais Ãªtre visible dans le code du navigateur.

-----

### **Ã‰tape 2 : Mettre Ã  jour le code du client**

Modifiez les fichiers cÃ´tÃ© client pour qu'ils communiquent avec votre nouveau proxy au lieu des API directes.

1.  **Modifier `client/src/services/sefariaSimple.ts` :**
    Ce fichier doit maintenant pointer vers les routes de votre proxy.

    ```typescript
    // Fichier : client/src/services/sefariaSimple.ts

    export const getBreslovIndex = async () => {
      // Appel au proxy pour l'index complet de la catÃ©gorie Breslev
      const response = await fetch('/sefaria/api/index/Breslov');
      if (!response.ok) {
        throw new Error('Failed to fetch Breslov index from proxy');
      }
      const data = await response.json();
      // La structure contient directement les livres dans `contents`
      return data.contents || [];
    };

    export const getText = (ref: string) => {
      // Appel au proxy pour un texte spÃ©cifique
      const cleanRef = ref.replace(/ /g, '_');
      return fetch(`/sefaria/api/v3/texts/${cleanRef}?context=0&commentary=0&pad=0&wrapLinks=false`)
        .then(r => {
          if (!r.ok) {
            throw new Error(`Proxy error fetching text: ${r.statusText}`);
          }
          return r.json();
        });
    };
    ```

2.  **Modifier `client/src/services/geminiSimple.ts` :**
    Ce service doit appeler votre propre route `/gemini/chat`.

    ```typescript
    // Fichier : client/src/services/geminiSimple.ts

    export const streamGemini = async (prompt: string, onChunk: (chunk: string) => void) => {
      const response = await fetch('/gemini/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt })
      });

      if (!response.ok || !response.body) {
        throw new Error('Failed to stream response from Gemini proxy');
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        onChunk(decoder.decode(value, { stream: true }));
      }
    };
    ```

3.  **Modifier `client/src/hooks/useTTSFixed.ts` (AmÃ©lioration de la synthÃ¨se vocale) :**
    Pour une meilleure expÃ©rience, notamment sur mobile, remplacez le contenu de ce fichier par une version qui gÃ¨re mieux le chargement des voix et offre un fallback.

    ```typescript
    // Fichier : client/src/hooks/useTTSFixed.ts
    import { useState, useCallback, useEffect } from 'react';
    import { Language } from '../types';

    export const useTTSFixed = ({ language, enabled }: { language: Language; enabled: boolean; }) => {
      const [isSpeaking, setIsSpeaking] = useState(false);
      const [voicesLoaded, setVoicesLoaded] = useState(false);

      const loadVoices = useCallback((): Promise<SpeechSynthesisVoice[]> => {
        return new Promise((resolve) => {
          if (voicesLoaded) {
            resolve(window.speechSynthesis.getVoices());
            return;
          }
          const voices = window.speechSynthesis.getVoices();
          if (voices.length > 0) {
            setVoicesLoaded(true);
            resolve(voices);
            return;
          }
          window.speechSynthesis.addEventListener('voiceschanged', () => {
            setVoicesLoaded(true);
            resolve(window.speechSynthesis.getVoices());
          }, { once: true });
        });
      }, [voicesLoaded]);

      const speak = useCallback(async (text: string) => {
        if (!enabled || !text.trim() || !window.speechSynthesis) return;

        stopTTS();
        const voices = await loadVoices();
        const utterance = new SpeechSynthesisUtterance(text);
        const langCode = language === 'he' ? 'he-IL' : language === 'en' ? 'en-US' : 'fr-FR';
        utterance.lang = langCode;

        const voice = voices.find(v => v.lang.startsWith(langCode.split('-')[0]) && v.name.includes('Google')) || voices.find(v => v.lang === langCode);
        if (voice) utterance.voice = voice;

        utterance.rate = 0.9;
        utterance.pitch = 1.0;
        utterance.onstart = () => setIsSpeaking(true);
        utterance.onend = () => setIsSpeaking(false);
        utterance.onerror = () => setIsSpeaking(false);

        window.speechSynthesis.speak(utterance);
      }, [enabled, language, loadVoices]);

      const stopTTS = useCallback(() => {
        if (window.speechSynthesis.speaking) {
          window.speechSynthesis.cancel();
        }
        setIsSpeaking(false);
      }, []);

      const speakGreeting = useCallback(() => {
        const greetings = {
          fr: "Shalom. SÃ©lectionnez un enseignement de la bibliothÃ¨que ou posez-moi une question.",
          en: "Shalom. Select a teaching from the library or ask a question.",
          he: "×©×œ×•×. ×‘×—×¨×• ×œ×™××•×“ ××”×¡×¤×¨×™×™×” ××• ×©××œ×• ×©××œ×”."
        };
        speak(greetings[language] || greetings.fr);
      }, [language, speak]);

      return { speak, stopTTS, isSpeaking, speakGreeting };
    };
    ```

-----

### **Ã‰tape 3 : Mettre Ã  jour la configuration du projet**

1.  **Modifier `package.json` pour lancer le client et le serveur simultanÃ©ment :**

    ```json
    {
      "name": "le-compagnon-du-coeur",
      "private": true,
      "version": "1.0.0",
      "type": "module",
      "scripts": {
        "dev": "concurrently \"npm:dev:client\" \"npm:dev:server\"",
        "dev:client": "vite",
        "dev:server": "node server.js",
        "build": "vite build",
        "preview": "vite preview"
      },
      "dependencies": {
        "@google/generative-ai": "^0.24.1",
        "cors": "^2.8.5",
        "express": "^4.21.2",
        "http-proxy-middleware": "^3.0.5",
        "node-fetch": "^3.3.2",
        "react": "^18.3.1",
        "react-dom": "^18.3.1"
      },
      "devDependencies": {
        "concurrently": "^9.2.0",
        // ... autres devDependencies
      }
    }
    ```

    N'oubliez pas d'installer `concurrently` si ce n'est pas dÃ©jÃ  fait : `npm install concurrently`

-----

### **RÃ©sumÃ© des actions Ã  effectuer :**

1.  **CrÃ©er `server.js`** Ã  la racine avec le code du proxy.
2.  **Mettre Ã  jour `package.json`** pour inclure les nouvelles dÃ©pendances et les scripts.
3.  **SÃ©curiser la clÃ© API Gemini** dans les "Secrets" de Replit.
4.  **Modifier `sefariaSimple.ts` et `geminiSimple.ts`** pour qu'ils appellent les routes du proxy (`/sefaria/...` et `/gemini/...`).
5.  **Remplacer le contenu de `useTTSFixed.ts`** par la version amÃ©liorÃ©e.
6.  Lancer l'application avec `npm run dev`.

Une fois ces modifications appliquÃ©es, l'application devrait Ãªtre pleinement fonctionnelle, stable, et sÃ©curisÃ©e. La bibliothÃ¨que se chargera correctement, les analyses de l'IA fonctionneront, et l'expÃ©rience utilisateur sera grandement amÃ©liorÃ©e.