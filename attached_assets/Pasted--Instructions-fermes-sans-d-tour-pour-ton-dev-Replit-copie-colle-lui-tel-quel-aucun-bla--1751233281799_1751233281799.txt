## ğŸ“‹ Instructions fermes & sans dÃ©tour pour ton dev Replit

*(copie-colle-lui tel quel ; aucun bla-bla hors de la check-list)*

---

### 0. RÃ¨gles de base

1. **Pas de promesses vides** : chaque tÃ¢che terminÃ©e doit Ãªtre dÃ©montrable (log ou capture).
2. **Pas dâ€™accÃ¨s direct Ã  Sefaria depuis le navigateur** â€“ toujours passer par **Express proxy** pour Ã©viter CORS.
3. **Toutes les clÃ©s** (`GEMINI_API_KEY`, etc.) **uniquement** dans les *Secrets* Replit â†’ `process.env`.
4. Code **ESM partout** (`"type":"module"` dans `package.json`) ; pas de `require()` pour le SDK Gemini (il est ESM-only).

---

### 1. Nettoyage & setup minimal

```bash
rm -rf node_modules && npm i            # repart propre
npm i express node-fetch@3 cors @google/generative-ai
```

`package.json`

```jsonc
{
  "type": "module",
  "scripts": { "dev": "node server.js" }
}
```

---

### 2. `server.js`  (proxy unique)

```js
import express from 'express';
import fetch from 'node-fetch';
import cors from 'cors';
import { GoogleGenerativeAI } from '@google/generative-ai';

const app = express();
app.use(cors());
app.use(express.json());

/* ---------- Sefaria proxy ---------- */
app.get('/sefaria/*', async (req, res) => {
  const target = 'https://www.sefaria.org' + req.originalUrl.replace('/sefaria', '');
  const r = await fetch(target);
  res.status(r.status);
  r.body.pipe(res);
});

/* ---------- Gemini proxy (stream) ---------- */
if (!process.env.GEMINI_API_KEY) throw new Error('â›”ï¸ GEMINI_API_KEY manquante');
const ai = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = ai.getGenerativeModel({
  model: 'gemini-1.5-flash-latest',
  systemInstruction: { role: 'system', parts: [{ text: 'Tu es Le Compagnon du CÅ“urâ€¦' }] }
});

app.post('/gemini/chat', async (req, res) => {
  try {
    const { prompt } = req.body;
    const chat = model.startChat();
    const result = await chat.sendMessageStream(prompt);

    res.setHeader('Content-Type', 'text/plain; charset=utf-8');
    res.setHeader('Transfer-Encoding', 'chunked');
    res.flushHeaders();

    for await (const chunk of result.stream) res.write(chunk.text());
    res.end();
  } catch (e) {
    console.error(e); res.status(500).json({ error: 'Gemini fail' });
  }
});

app.listen(3000, () => console.log('ğŸš€ Proxy up : http://localhost:3000'));
```

*Test immÃ©diat* :

```bash
curl "http://localhost:3000/sefaria/api/texts/Genesis.1.1"
curl -X POST -H "Content-Type: application/json" -d '{"prompt":"Bonjour"}' http://localhost:3000/gemini/chat
```

Les deux appels doivent rÃ©pondre ; sinon on ne continue pas.

---

### 3. Service Sefaria cÃ´tÃ© client (`src/services/sefaria.ts`)

```ts
export const getBreslovIndex = async () => {
  const r = await fetch('/sefaria/api/index/');
  const idx = await r.json();
  const cha = idx.find((c:any) => c.category === 'Chasidut')?.contents ?? [];
  const bre = cha.find((c:any) => c.category === 'Breslov')?.contents ?? [];
  return bre;                              // tableau hiÃ©rarchique complet
};

export const getText = (ref: string) =>
  fetch(`/sefaria/api/v3/texts/${ref.replace(/ /g,'_')}?context=0&commentary=0&pad=0&wrapLinks=false`)
    .then(r => r.json());
```

---

### 4. Service Gemini cÃ´tÃ© client (`src/services/gemini.ts`)

```ts
export const streamGemini = async (prompt: string, onChunk: (t:string)=>void) => {
  const res = await fetch('/gemini/chat', {
    method: 'POST', headers: { 'Content-Type':'application/json' },
    body: JSON.stringify({ prompt })
  });
  const reader = res.body!.getReader();
  const dec = new TextDecoder();
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    onChunk(dec.decode(value, { stream: true }));
  }
};
```

---

### 5. UI â€“ fonctionnalitÃ©s obligatoires

| Zone                                           | Action â†’ appel                      |
| ---------------------------------------------- | ----------------------------------- |
| **Sidebar** (clic sur un enseignement)         | `streamGemini('study', {textFull})` |
| **ChatInput**                                  | `streamGemini('general', {text})`   |
| **Textarea â€œAnalyser un extraitâ€**             | mode **snippet**                    |
| **Textarea â€œConseil âœ¨â€**                       | mode **advice**                     |
| **Bouton â€œPoints ClÃ©sâ€** sous rÃ©ponses >200 c. | mode **summary**                    |

Prompt builder minimal :

```ts
const buildPrompt = (mode,p)=>`MODE=${mode}\nQUESTION=${p.text}`;
```

---

### 6. TTS & STT

* **Hook `useTTS`** (lecture).
* Dans `ChatInput`, Web Speech API pour dictÃ©e (si dispo).

---

### 7. VÃ©rifications finales (Ã  montrer dans le log Replit)

1. `GET /sefaria/...` â†’ 200.
2. `POST /gemini/chat` â†’ flux reÃ§u.
3. Sidebar affiche toute lâ€™arbo Breslov (â‰ˆ > 8 titres).
4. Clic â‡’ texte complet apparaÃ®t dans la viewer et **stream IA** dÃ©marre.
5. TTS lit la rÃ©ponse.
6. Aucun appel direct Ã  `https://www.sefaria.org` dans le rÃ©seau du navigateur (tout passe par le proxy).

ğŸ‘‰ **Tout Ã§a doit Ãªtre opÃ©rationnel avant dâ€™ajouter du CSS fancy**. Pas de design tant que le data-flow nâ€™est pas 100 % OK.

---

**Fin des ordres. Pas de diversion, pas de â€œje vais le faireâ€ â€“ seulement des commits prouvables.**
